# AGENTS.md — Контекст для AI-ассистентов

Этот файл содержит важную информацию о проекте, архитектурных решениях, правилах кодирования и уроках, извлеченных в
процессе разработки. Используйте этот контекст перед началом работы над задачами.

## 1. Обзор проекта
**Student Assistant** — Android-приложение для студентов и школьников.
* **Стек:** Kotlin, Jetpack Compose (Material 3), Room, Dagger 2, Coroutines & Flow.
* **Сборка:** Gradle Kotlin DSL, Version Catalogs (`libs.versions.toml`).
* **Архитектура:** Многомодульная (`app`, `features/*`, `core/*`, `common/*`).

## 2. Терминология
* **Lesson**: В коде и комментариях переводить как **"Занятие"**, а не "Урок". Это универсальный термин для школы и
  вуза.
* **Semester**: Семестр или четверть.
* **Homework**: Домашнее задание.

## 3. Архитектура и Ключевые Решения

### База Данных (Room)
* **Room** является единственным источником истины.
* **Сложные запросы:** В `LessonDao` используется сложный SQL-запрос с `UNION` для объединения регулярных занятий (по
  дням недели) и разовых занятий (по датам).
* **Хранение недель:** Повторение по неделям хранится как строка из '0' и '1' (например, "101" — 1-я и 3-я недели). В
  SQL это обрабатывается через функцию `substr`.
    * **Важно:** Не переносите логику фильтрации недель или дат из SQL в Kotlin (`filter` в памяти). Текущая реализация
      оптимизирована для производительности.

### Навигация (Navigation 3)
* Используется библиотека `androidx.navigation3`.
* Реализована собственная обертка в модуле `:common:navigation`:
    * `NavigationState` — хранит состояние бэкстека.
    * `Navigator` — управляет переходами.
* Маршруты (`Routes`) объявляются как `Serializable` sealed интерфейсы/классы (например, `ScheduleRoute`,
  `HomeworksRoute`) внутри `api` подмодулей фич.

### Dependency Injection (Dagger 2)
* Используется классический Dagger 2 (не Hilt).
* **Component Holder Pattern:** Каждый feature-модуль имеет свой `ComponentHolder` (синглтон), который хранит экземпляр
  компонента.
* **Assisted Injection:** Активно используется для создания ViewModel с параметрами (например, `id` урока),
  передаваемыми через навигацию.

### UI (Jetpack Compose)
* Полностью на **Material 3**.
* Используется кастомная система отступов через `LocalDimensions` (файл `Dimensions.kt` в `:core:style`).
    * **Правило:** Используйте `MaterialTheme.dimensions` только для стандартных отступов (экраны, карточки), уже
      определенных в `Dimensions`. Для специфических отступов внутри компонентов используйте хардкод значений в `dp`.

## 4. Правила написания кода
* **Модификаторы доступа:** По умолчанию используйте `internal`. `public` только для классов/интерфейсов в `api` модулях
  или для DI провайдеров. Вспомогательные классы для тестов (например, `MainDispatcherRule`) также должны быть
  `internal`.
* **Flow:** Используйте `StateFlow` в ViewModel для UI-состояния. При использовании оператора `stateIn` всегда
  указывайте `SharingStarted.Default` (extension-свойство из пакета `ru.erdenian.studentassistant.utils`), которое
  задает `stopTimeoutMillis = 5_000L` для корректной обработки смены конфигурации.
* **Строки:** Все строки должны быть вынесены в модуль `:core:strings`.
* **Code Style:** Проект использует `detekt`. Конфигурация лежит в `detekt-config.yml`. Перед коммитом запускайте
  `detektMain`.
* **Документация:** При выяснении новых подробностей о написании кода нужно также обновлять AGENTS.md и README.md.
  На неочевидные моменты нужно добавлять комментарии в код. Вся документация и комментарии должны быть на русском языке,
  старые комментарии на английском языке при изменении файла нужно переводить на русский.

## 5. Тестирование
* **Покрытие кода (Coverage):** Мы стремимся к **100% покрытию кода** тестами.
* **Актуализация:** При любом изменении функциональности соответствующие тесты **должны быть обновлены**.
* **Работа с непокрытым кодом:** Если вы вносите изменения в участок кода, который ранее не был протестирован, вы
  **обязаны** написать тесты для этого участка. Нельзя модифицировать логику, оставляя её без тестов.
* **Unit-тесты (test):** Основной приоритет. Используются `Fake`-реализации репозиториев и DAO (`FakeLessonDao`,
  `FakeSemesterDao`), находящиеся в `features/repository/src/test/.../Fakes.kt`.
    * **Правило для Fakes:** Они должны имитировать поведение SQL, включая сортировку (`sortedWith`) и автогенерацию ID.
* **Android-тесты (androidTest):** Используются в основном для проверки корректности SQL-запросов в Room (особенно
  логика битовых масок недель и дат).
* **Запрещено:** Использовать `LocalDate.now()` и другие функции, зависящие от внешнего состояния, в тестах без явной
  подмены (моков/фикстур).
* **Зависимости:** При написании тестов в модуле добавляйте `testImplementation(libs.bundles.test.unit)` в блок
  `dependencies` соответствующего `build.gradle.kts`.

## 6. Структура build.gradle.kts
Соблюдайте следующий порядок блоков в `dependencies`:
1. **Private**: Зависимости от других модулей проекта (`implementation(project(...))`).
2. **Tests**: Тестовые зависимости (`testImplementation`, `androidTestImplementation`).
3. **Kotlin**: Зависимости Kotlin и корутин.
4. **AndroidX**: Библиотеки Android Jetpack (Compose, Lifecycle, Room и т.д.).
5. **Core**: Базовые библиотеки (Dagger и прочее).

## 7. Git и Коммиты
* Сообщения коммитов должны быть на **русском языке**.
* Пишите понятные и лаконичные описания изменений.
* **Запрещено:** Использовать стиль Conventional Commits (например, `feat:`, `fix:`). Начинайте сообщение с большой
  буквы.

## 8. Ведение CHANGELOG.md
Все изменения, влияющие на пользователя или поведение приложения, должны быть отражены в `CHANGELOG.md` в секции
`[Unreleased]`.

**Обязательный порядок секций:**
1. `Fixed`: Исправления багов.
2. `Added`: Новые функции.
3. `Changed`: Изменения в существующем функционале.
4. `Removed`: Удаленные функции.

Другие типы секций (например, `Deprecated` или `Security`) не используются.

**Что НЕ нужно записывать:**
* Изменения сборки, обновление зависимостей (если это не влияет на пользователя).
* Рефакторинг без изменения поведения.
* Исправление стиля кода.

## 9. Известные особенности
* **Проблемы с производительностью:** Логика получения занятий на конкретный день была оптимизирована через SQL. Любые
  изменения в `LessonDao.getAllFlow` требуют тщательного профилирования.
* **Удаление сущностей:** При удалении занятия, для которого есть домашние задания, пользователю предлагается выбор (
  удалить или оставить задания). Эта логика реализована во ViewModels.

## 10. Разработка UI (Jetpack Compose)

### 10.1. Кастомные компоненты
* **Расположение:**
    * Если компонент используется только на одном экране -> пакет `composable` рядом с кодом экрана.
    * Если компонент используется в разных экранах одной фичи -> общий пакет `composable` внутри модуля фичи.
    * Если компонент используется в разных модулях -> модуль `:common:uikit`.
* **Документация (KDoc):** Обязательна. Должна описывать назначение, параметры и поведение компонента (по аналогии с
  документацией Google).
* **Параметры:**
    * Список параметров может варьироваться в зависимости от нужд компонента (`enabled`, `selected`, `colors`,
      `interactionSource`, и т.д.).
    * `modifier: Modifier = Modifier` — **обязательно** должен быть **первым необязательным** параметром функции (
      согласно Google Compose API Guidelines).
* **Стилизация:**
    * Используйте паттерн `Defaults` и `Colors`.
    * Создавайте объект `MyComponentDefaults` с методом `myComponentColors(...)`.
    * Создавайте интерфейс (и приватную реализацию) `MyComponentColors`.

### 10.2. Архитектура экранов
Каждый экран должен быть разделен на две сущности для соблюдения принципа Separation of Concerns и упрощения
тестирования/превью.

**1. Screen (`MyScreen.kt`)**
* **Ответственность:** Взаимодействие с системным окружением и логикой.
* Получает `ViewModel` (через DI).
* Собирает `StateFlow` в Compose State (`collectAsState`).
* Обрабатывает навигацию (получает `LocalNavigator`).
* Показывает диалоги (AlertDialog, ModalBottomSheet), так как они находятся поверх контента.
* Передает данные и обработчики событий (лямбды) в `Content`.

**2. Content (`MyContent.kt`)**
* **Ответственность:** Отображение UI.
* Должен быть **Stateless** (насколько это возможно).
* Принимает только простые данные (String, List, Data Class) и callback-функции.
* **Запрещено:** Передавать `ViewModel`, `Flow` или `NavController` в Content-функцию.
* Содержит корневой `Scaffold` или макет экрана.

### 10.3. UI Previews
* **Обязательность:** Все кастомные компоненты и `Content`-функции экранов должны иметь Preview.
* **Обертка:**
    * Все Preview должны быть обернуты в `AppTheme`.
  * Рекомендуется добавлять `Surface` внутри темы для корректного отображения фона, если без этого фона компонент
    сложно рассмотреть (например, если у компонента нет своей подложки): `AppTheme { Surface { ... } }`.
* **Мульти-превью (Multipreview Annotations):**
    * Для стандартизации и уменьшения шаблонного кода используйте кастомные аннотации (должны быть определены в модуле
      `:core:style`).
    * **`@ThemePreviews`**: Генерирует превью для Светлой и Темной тем. Используйте для всех компонентов.
    * **`@OrientationPreviews`**: Генерирует превью для Портретной и Альбомной ориентаций. Используйте для полноэкранных
      `Content` функций.
* **Синтаксис:**
    * **Видимость:** Функции Preview должны быть `private`.
    * **Именование:** Всегда указывайте параметр `name` для описания состояния (например, `@Preview(name = "Loading")`).
    * **Группировка:** Основная группировка происходит автоматически через мульти-превью. Если требуется специфическая
      группировка в Android Studio, используйте параметр `group` в аннотации `@Preview`.
* **Сценарии покрытия (Coverage):**
    * **Темы и Ориентация:** Покрываются автоматически через `@ThemePreviews` и `@OrientationPreviews`.
    * **Состояния экрана (States):** Loading, Empty, Content, Error и другие специфичные состояния.
    * **Состояния компонента:** Enabled/Disabled, Selected/Unselected, Focused и другие специфичные состояния.
    * **Данные (Data):** Используйте сэмпл-данные из `:common:sampledata`.
    * **Граничные случаи (Edge Cases):**
        * **Текст:** Очень длинный (проверка переносов, `ellipsis`), очень короткий, пустая строка. Используйте
          `ru.erdenian.studentassistant.sampledata.Semesters.long` и подобные.
        * **Списки:** Пустой список, мало элементов (меньше высоты экрана), очень много элементов (проверка скролла).
        * **Размер экрана:** Проверка на маленьких экранах (для избежания наложений).

## 11. Работа со строковыми ресурсами (strings.xml)
Все строковые ресурсы находятся в модуле `:core:strings`.

### Именование ключей (Naming)
* **Префикс:** Обязателен для всех строк экрана/компонента.
* **Формирование префикса:** Берется название экрана (например, `LessonEditorContent`), отбрасываются суффиксы `Screen`,
  `Content`, `View`. Из оставшихся слов берутся первые буквы в нижнем регистре.
    * `LessonEditorContent` -> `LessonEditor` -> **`le_`**
    * `SemesterEditorScreen` -> `SemesterEditor` -> **`se_`**
    * `HomeworksScreen` -> **`h_`**
* **Разрешение коллизий:** Если вычисленный префикс уже занят другим экраном, используйте альтернативный, добавив
  следующую характерную букву названия или другую уникальную комбинацию.
    * *Пример:* `SemesterEditor` уже занял префикс **`se_`**.
    * *Пример:* Для `ScheduleEditor` (который тоже мог бы быть `se`) используем **`sce_`**.

### Структура файла
* **Регионы:** Строки верхнего уровня группируются по модулям (например, `schedule`, `homeworks`).
    * Каждый регион должен открываться комментарием `<!-- region module_name -->`.
    * И обязательно закрываться комментарием `<!-- endregion -->`.
* **Секции экранов:** Внутри региона строки группируются по экранам.
    * Используйте заголовок `<!-- Screen Name -->`.
    * **Важно:** Строки должны следовать сразу за заголовком без разделения пустыми строками.

### Порядок строк
1. **Основной контент:** Строки располагаются в том же порядке, в котором они появляются на экране: **сверху вниз, слева
   направо**.
2. **Диалоги:** Строки для диалогов (Alert Dialogs, Bottom Sheets), вызываемых с этого экрана, располагаются **в конце**
   секции экрана. Внутри группы диалога порядок также сверху вниз (Заголовок -> Сощбщение -> Кнопки).

### Принципы
* **Запрет хардкода:** В верстке (Composable-функциях, XML-разметке) не должно быть захардкоженных строк. Все видимые
  пользователю тексты должны быть вынесены в `strings.xml`.
* **Дублирование вместо переиспользования:** Не используйте одну и ту же строку (например, "Save" или "Cancel") для
  разных экранов. Лучше создать дубликат с уникальным префиксом (например, `le_save` и `se_save`). Это позволяет менять
  контекст одного экрана, не ломая другие.
* **Форматирование:**
    * Используйте символ многоточия **`…`** (U+2026) вместо трех точек `...` для индикации прогресса или обрезанного
      текста.
    * Для плейсхолдеров используйте нумерованные аргументы: `%1$s`, `%2$d`.
