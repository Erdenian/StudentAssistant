# AGENTS.md — Контекст для AI-ассистентов

Этот файл содержит важную информацию о проекте, архитектурных решениях, правилах кодирования и уроках, извлеченных в
процессе разработки. Используйте этот контекст перед началом работы над задачами.

## 1. Обзор проекта
**Student Assistant** — Android-приложение для студентов и школьников.
* **Стек:** Kotlin, Jetpack Compose (Material 3), Room, Dagger 2, Coroutines & Flow.
* **Сборка:** Gradle Kotlin DSL, Version Catalogs (`libs.versions.toml`).
* **Архитектура:** Многомодульная (`app`, `features/*`, `core/*`, `common/*`).

## 2. Терминология
* **Lesson**: В коде и комментариях переводить как **"Занятие"**, а не "Урок". Это универсальный термин для школы и
  вуза.
* **Semester**: Семестр или четверть.
* **Homework**: Домашнее задание.

## 3. Архитектура и Многомодульность

Проект построен на принципах чистой архитектуры и строгой иерархии модулей.

### Иерархия зависимостей
Зависимости направлены только **снизу вверх**. Циклические зависимости запрещены.

1. **App (`:app`)**
    * Точка входа (Application, Activity).
    * Связывает все модули воедино (DI Root).
    * Зависит от всех Feature-модулей.

2. **Features (`:features:*`)**
    * Реализуют конкретные пользовательские сценарии (Расписание, Настройки, БД).
    * Могут зависеть от модулей `common` и `core`.
    * Feature-модули **не могут** зависеть от других Feature-модулей (implementation), но могут зависеть от их
      **API-модулей** (`:features:some_feature:api`).

3. **Common (`:common:*`)**
    * Общий код, переиспользуемый между фичами (UI-kit, утилиты, навигация).
    * Может зависеть от `core`.
    * Не может зависеть от `features` или `app`.

4. **Core (`:core:*`)**
    * Фундаментальные ресурсы и логика (строки, стили/темы).
    * Самый нижний уровень. Не зависит ни от чего внутри проекта.

### Структура Feature-модулей
Каждая фича (например, `schedule`, `homeworks`) разделена на два модуля для обеспечения слабой связности и ускорения
сборки:

#### 1. API модуль (`:features:myfeature:api`)
Содержит только публичные контракты:
* **Маршруты (Routes):** `Sealed interfaces`, описывающие экраны фичи (например, `ScheduleRoute`). Наследуются от
  `NavKey`. Маршруты объявляются как `Serializable` sealed интерфейсы/классы.
* **Интерфейс API:** Интерфейс (например, `ScheduleApi`) с методом `addToGraph`, который регистрирует экраны в
  навигации.
* **Общие сущности:** Data-классы, необходимые другим модулям.

#### 2. Implementation модуль (`:features:myfeature`)
Содержит реализацию:
* **Screens & Contents:** Composable-функции экранов.
* **ViewModels:** Логика представления.
* **Внутренняя логика:** UseCases, Repository implementations (если применимо).
* **Реализация DI:** Реализация Dagger-компонента и `ApiImpl`.

## 4. Ключевые технические решения

### База Данных (Room)
* **Room** является единственным источником истины.
* **Сложные запросы:** В `LessonDao` используется сложный SQL-запрос с `UNION` для объединения регулярных занятий (по
  дням недели) и разовых занятий (по датам).
* **Хранение недель:** Повторение по неделям хранится как строка из '0' и '1' (например, "101" — 1-я и 3-я недели). В
  SQL это обрабатывается через функцию `substr`.
    * **Важно:** Не переносите логику фильтрации недель или дат из SQL в Kotlin (`filter` в памяти). Текущая реализация
      оптимизирована для производительности. Логика фильтрации (например, проверка битовой маски недель) выполняется на
      стороне SQL, а не в Kotlin. Это критично для производительности.

### Навигация (Navigation 3)
* Используется библиотека `androidx.navigation3`.
* Реализована собственная обертка в модуле `:common:navigation`:
    * `NavigationState` — хранит состояние бэкстека.
    * `Navigator` — управляет переходами.
* Маршруты (`Routes`) строго типизированы через Kotlin Serialization, объявляются как `Serializable` sealed
  интерфейсы/классы (например, `ScheduleRoute`, `HomeworksRoute`) внутри `api` подмодулей фич.
* Регистрация экранов происходит в методе `addToGraph` внутри реализации API фичи.

### Dependency Injection (Dagger 2)
* Используется классический Dagger 2 (не Hilt).
* **Component Holder Pattern:** Каждый feature-модуль имеет свой `ComponentHolder` (синглтон), который хранит экземпляр
  компонента. Он имеет метод `create(dependencies)`, инициализирующий граф.
* **Dependencies Interface:** Каждая фича объявляет интерфейс `MyFeatureDependencies`, перечисляя, что ей нужно извне
  (обычно `Application`, `RepositoryApi` и т.д.).
* **Assisted Injection:** Активно используется для создания ViewModel с параметрами (например, `id` урока),
  передаваемыми через навигацию. Используйте `@AssistedInject` и `@AssistedFactory`.

### UI (Jetpack Compose)
* Полностью на **Material 3**.
* Используется кастомная система отступов через `LocalDimensions` (файл `Dimensions.kt` в `:core:style`).
    * **Правило:** Используйте `MaterialTheme.dimensions` только для стандартных отступов (экраны, карточки), уже
      определенных в `Dimensions`. Для специфических отступов внутри компонентов используйте хардкод значений в `dp`.
      `MaterialTheme.dimensions` — это точка доступа к ним.
* **Разделение Screen/Content:**
    * `Screen`: Принимает ViewModel, управляет состоянием, навигацией и диалогами.
    * `Content`: Принимает простые данные и лямбды. Полностью отображает UI.

## 5. Правила написания кода
* **Модификаторы доступа:** По умолчанию используйте `internal`. `public` только для классов/интерфейсов в `api` модулях
  или для DI провайдеров. Вспомогательные классы для тестов (например, `MainDispatcherRule`) также должны быть
  `internal`.
* **Flow:** Используйте `StateFlow` в ViewModel для UI-состояния. При использовании оператора `stateIn` всегда
  указывайте `SharingStarted.Default` (extension-свойство из пакета `ru.erdenian.studentassistant.utils`), которое
  задает `stopTimeoutMillis = 5_000L` для корректной обработки смены конфигурации.
* **Строки:** Все строки должны быть вынесены в модуль `:core:strings`.
* **Code Style:** Проект использует `detekt`. Конфигурация лежит в `detekt-config.yml`. Перед коммитом запускайте
  `detektMain`.
* **Документация:** При выяснении новых подробностей о написании кода нужно также обновлять AGENTS.md и README.md. На
  неочевидные моменты нужно добавлять комментарии в код. Вся документация и комментарии должны быть на русском языке,
  старые комментарии на английском языке при изменении файла нужно переводить на русский.

## 6. Тестирование
* **Покрытие кода (Coverage):** Мы стремимся к **100% покрытию кода** тестами.
* **Актуализация:** При любом изменении функциональности соответствующие тесты **должны быть обновлены**.
* **Работа с непокрытым кодом:** Если вы вносите изменения в участок кода, который ранее не был протестирован, вы *
  *обязаны** написать тесты для этого участка. Нельзя модифицировать логику, оставляя её без тестов.
* **Unit-тесты (test):** Основной приоритет. Используются `Fake`-реализации репозиториев и DAO (`FakeLessonDao`,
  `FakeSemesterDao`), находящиеся в `features/repository/src/test/.../Fakes.kt`.
    * **Правило для Fakes:** Они должны имитировать поведение SQL, включая сортировку (`sortedWith`) и автогенерацию ID,
      а также каскадное удаление.
* **Android-тесты (androidTest):** Используются в основном для проверки корректности SQL-запросов в Room (особенно
  логика битовых масок недель и дат).
* **Запрещено:** Использовать `LocalDate.now()` и другие функции, зависящие от внешнего состояния, в тестах без явной
  подмены (моков/фикстур).
* **Зависимости:** При написании тестов в модуле добавляйте `testImplementation(libs.bundles.test.unit)` в блок
  `dependencies` соответствующего `build.gradle.kts`.

## 7. Структура build.gradle.kts
Соблюдайте следующий порядок блоков в `dependencies`:
1. **Private**: Зависимости от других модулей проекта (`implementation(project(...))`).
2. **Tests**: Тестовые зависимости (`testImplementation`, `androidTestImplementation`).
3. **Kotlin**: Зависимости Kotlin и корутин.
4. **AndroidX**: Библиотеки Android Jetpack (Compose, Lifecycle, Room и т.д.).
5. **Core**: Базовые библиотеки (Dagger и прочее).

## 8. Git и Коммиты
* Сообщения коммитов должны быть на **русском языке**.
* Пишите понятные и лаконичные описания изменений.
* **Запрещено:** Использовать стиль Conventional Commits (например, `feat:`, `fix:`). Начинайте сообщение с большой
  буквы.

## 9. Ведение CHANGELOG.md
Все изменения, влияющие на пользователя или поведение приложения, должны быть отражены в `CHANGELOG.md` в секции
`[Unreleased]`.

**Обязательный порядок секций:**
1. `Fixed`: Исправления багов.
2. `Added`: Новые функции.
3. `Changed`: Изменения в существующем функционале.
4. `Removed`: Удаленные функции.

Другие типы секций (например, `Deprecated` или `Security`) не используются.

**Что НЕ нужно записывать:**
* Изменения сборки, обновление зависимостей (если это не влияет на пользователя).
* Рефакторинг без изменения поведения.
* Исправление стиля кода.

## 10. Известные особенности
* **Проблемы с производительностью:** Логика получения занятий на конкретный день была оптимизирована через SQL. Любые
  изменения в `LessonDao.getAllFlow` требуют тщательного профилирования.
* **Удаление сущностей:** При удалении занятия, для которого есть домашние задания, пользователю предлагается выбор (
  удалить или оставить задания). Эта логика реализована во ViewModels.

## 11. Разработка UI (Jetpack Compose)

### 11.1. Кастомные компоненты
* **Расположение:**
    * Если компонент используется только на одном экране -> пакет `composable` рядом с кодом экрана.
    * Если компонент используется в разных экранах одной фичи -> общий пакет `composable` внутри модуля фичи.
    * Если компонент используется в разных модулях -> модуль `:common:uikit`.
* **Документация (KDoc):** Обязательна. Должна описывать назначение, параметры и поведение компонента (по аналогии с
  документацией Google).
* **Параметры:**
    * Список параметров может варьироваться в зависимости от нужд компонента (`enabled`, `selected`, `colors`,
      `interactionSource`, и т.д.).
    * `modifier: Modifier = Modifier` — **обязательно** должен быть **первым необязательным** параметром функции (
      согласно Google Compose API Guidelines).
* **Стилизация:**
    * Используйте паттерн `Defaults` и `Colors`.
    * Создавайте объект `MyComponentDefaults` с методом `myComponentColors(...)`.
    * Создавайте интерфейс (и приватную реализацию) `MyComponentColors`.

### 11.2. Архитектура экранов
Каждый экран должен быть разделен на две сущности для соблюдения принципа Separation of Concerns и упрощения
тестирования/превью.

**1. Screen (`MyScreen.kt`)**
* **Ответственность:** Взаимодействие с системным окружением и логикой.
* Получает `ViewModel` (через DI).
* Собирает `StateFlow` в Compose State (`collectAsState`).
* Обрабатывает навигацию (получает `LocalNavigator`).
* Показывает диалоги (AlertDialog, ModalBottomSheet), так как они находятся поверх контента.
* Передает данные и обработчики событий (лямбды) в `Content`.

**2. Content (`MyContent.kt`)**
* **Ответственность:** Отображение UI.
* Должен быть **Stateless** (насколько это возможно).
* Принимает только простые данные (String, List, Data Class) и callback-функции.
* **Запрещено:** Передавать `ViewModel`, `Flow` или `NavController` в Content-функцию.
* Содержит корневой `Scaffold` или макет экрана.

### 11.3. UI Previews
* **Обязательность:** Все кастомные компоненты и `Content`-функции экранов должны иметь Preview.
* **Обертка (AppTheme + Surface):**
    * Все Preview должны быть обернуты в `AppTheme`.
  * **Важно:** Оборачивайте компонент в `Surface` внутри `AppTheme`, если у компонента **нет собственного фона**
    (например, кнопки, ячейки, текст).
  * Если компонент уже имеет фон (например, `Scaffold` в Content-функциях экранов, диалоги, карточки), `Surface`
    добавлять **не нужно**.
* **Аннотации (Multipreview):**
    * Используйте стандартные или кастомные Multipreview аннотации из модуля `:core:style`, чтобы избежать дублирования.
    * **`@AppPreviews`**: Используйте для атомарных компонентов.
    * **`@ScreenPreviews`**: Используйте для полных экранов (`Content`).
* **Данные (PreviewParameter):**
    * Избегайте создания множества функций Preview для отображения разных состояний данных (например, короткий/длинный
      текст).
  * Используйте `@PreviewParameter` с реализацией `PreviewParameterProvider`. Данные брать из `:common:sampledata`.
* **Синтаксис:**
    * **Видимость:** Функции Preview должны быть `private`.
  * **Именование:** Всегда указывайте параметр `name` для описания состояния (например, `@Preview(name = "Loading")`),
    если не используете Multipreview, который делает это автоматически.
* **Сценарии покрытия (Coverage):**
    * **Темы и Ориентация:** Покрываются автоматически через Multipreview аннотации из модуля `:core:style`.
    * **Состояния экрана (States):** Loading, Empty, Content, Error и другие специфичные состояния.
    * **Состояния компонента:** Enabled/Disabled, Selected/Unselected, Focused и другие специфичные состояния.
    * **Данные (Data):** Используйте сэмпл-данные из `:common:sampledata`.
    * **Граничные случаи (Edge Cases):**
        * **Текст:** Очень длинный (проверка переносов, `ellipsis`), очень короткий, пустая строка. Используйте
          `ru.erdenian.studentassistant.sampledata.Semesters.long` и подобные.
        * **Списки:** Пустой список, мало элементов (меньше высоты экрана), очень много элементов (проверка скролла).
        * **Размер экрана:** Проверка на маленьких экранах (для избежания наложений).

## 12. Работа со строковыми ресурсами (strings.xml)
Все строковые ресурсы находятся в модуле `:core:strings`.

### Именование ключей (Naming)
* **Префикс:** Обязателен для всех строк экрана/компонента.
* **Формирование префикса:** Берется название экрана (например, `LessonEditorContent`), отбрасываются суффиксы `Screen`,
  `Content`, `View`. Из оставшихся слов берутся первые буквы в нижнем регистре.
    * `LessonEditorContent` -> `LessonEditor` -> **`le_`**
    * `SemesterEditorScreen` -> `SemesterEditor` -> **`se_`**
    * `HomeworksScreen` -> **`h_`**
* **Разрешение коллизий:** Если вычисленный префикс уже занят другим экраном, используйте альтернативный, добавив
  следующую характерную букву названия или другую уникальную комбинацию.
    * *Пример:* `SemesterEditor` уже занял префикс **`se_`**.
    * *Пример:* Для `ScheduleEditor` (который тоже мог бы быть `se`) используем **`sce_`**.

### Структура файла
* **Регионы:** Строки верхнего уровня группируются по модулям (например, `schedule`, `homeworks`).
    * Каждый регион должен открываться комментарием `<!-- region module_name -->`.
    * И обязательно закрываться комментарием `<!-- endregion -->`.
* **Секции экранов:** Внутри региона строки группируются по экранам.
    * Используйте заголовок `<!-- Screen Name -->`.
    * **Важно:** Строки должны следовать сразу за заголовком без разделения пустыми строками.

### Порядок строк
1. **Основной контент:** Строки располагаются в том же порядке, в котором они появляются на экране: **сверху вниз, слева
   направо**.
2. **Диалоги:** Строки для диалогов (Alert Dialogs, Bottom Sheets), вызываемых с этого экрана, располагаются **в конце**
   секции экрана. Внутри группы диалога порядок также сверху вниз (Заголовок -> Сообщение -> Кнопки).

### Принципы
* **Запрет хардкода:** В верстке (Composable-функциях, XML-разметке) не должно быть захардкоженных строк. Все видимые
  пользователю тексты должны быть вынесены в `strings.xml`.
* **Дублирование вместо переиспользования:** Не используйте одну и ту же строку (например, "Save" или "Cancel") для
  разных экранов. Лучше создать дубликат с уникальным префиксом (например, `le_save` и `se_save`). Это позволяет менять
  контекст одного экрана, не ломая другие.
* **Форматирование:**
    * Используйте символ многоточия **`…`** (U+2026) вместо трех точек `...` для индикации прогресса или обрезанного
      текста.
    * Для плейсхолдеров используйте нумерованные аргументы: `%1$s`, `%2$d`.
